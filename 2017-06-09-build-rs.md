# build.rs

Коллеги из Яндекса просили, чтобы я не переставал писать.
Раньше я мог писать в этушку, а теперь у меня пропал доступ.

Я не нашёл хороший сервис, где можно было бы вести блог,
поэтому попробую написать пару заметок здесь.

Сегодня напишу немного про `build.rs`.

Небольшие программы и библиотеки на Rust обычно собираются программой
[Cargo](https://crates.io/). В ней всё довольно удобно сделано —
никаких сложных скриптов сборки писать не надо, вообще никаких
правил сборки не надо. Типичный файл `Cargo.toml`, описывающий сборку,
не содержит вообще никаких инструкций, только описание зависимостей
и метаданные (автор, лицензия, версия и т. п.)

Посмотрите, например,
на [Cargo.toml в библиотеке num_cpus](https://github.com/seanmonstar/num_cpus/blob/master/Cargo.toml)
(это библиотека, которая возвращает число процессоров в системе).

Для более сложных систем Cargo, наверное, работать не будет,
и стоит использовать [Bazel](https://github.com/bazelbuild/rules_rust)
или [BUCK](https://buckbuild.com/rule/rust_library.html).

Но для всего open source используется именно Cargo.

## Собственно build.rs

Иногда встроенных в Cargo средств не хватает. Например,
* иногда нужно что-то узнать о системе, и в зависимости от этого указать разные
  флаги компиляции (например, версию openssl)
* иногда нужно перед сборкой сгенерировать файлы (например, protobuf)

Для этого в Cargo придумали файл `build.rs`. `build-rs` — это произвольная настоящая
обычная программа на Rust, которая выполняется перед сборкой. Никаких ограничений,
никакого особого синтаксиса. Обычный файл с функцией `main`.

Эта программа может иметь зависимости, которые указываются в cекции
`[build-depends]` в `Cargo.toml`.

Например, в `[build-depends]` можно подключить библиотеку, которая
вызывает [gcc](https://github.com/alexcrichton/gcc-rs), и скомпилировать что-нибудь простое
перед компиляцией файлов Rust.

А ещё в `build.rs` можно написать на stdout 
[инструкции компилятору](http://doc.crates.io/build-script.html#outputs-of-the-build-script). Например,
* параметры для макросов (типа `-DBUILD_YEAR=2017` в C++)
* флаги линкеру

## Например, openssl

Например, в библиотеке openssl `build.rs`
[очень длинный](https://github.com/sfackler/rust-openssl/blob/master/openssl-sys/build.rs).
Cреди прочего этот скрипт
* ищет, где в системе установлен правильный openssl (например, на OSX библиотека проверяет,
а не установили ли openssl программой homebrew)
* выдаёт красивое сообщение об ошибке, если openssl не установлен
* узнаёт версию openssl, чтобы сгенерировать флаги компилятору Rust, и в зависимости от них
  предоставить клиенту библиотеки возможности, доступные только в новых версиях

## Напрмиер, protobuf

В моей библиотеке protobuf с помощью `build.rs`
[генерируются тесты](https://github.com/stepancheg/rust-protobuf/blob/master/protobuf-test/build.rs).

Запускется компилятор `protoc` и генерируются исходники на Rust по-разному в зависимости от того,
какая версия `protoc` установлена в системе, и какие параметры сборки библиотеки нужны.

## О чём это всё

Этот пост о том, как можно делать простые и удобные инструменты.

`Cargo.toml` очень простой и ограниченный. `build.rs` тоже ограниченный и не всегда удобный.
Но на практике оказывается, что если нужно решить какую-то нетривиальную задачу, то её
довольно несложно (по сравнению с `CMake`, например, не говоря уж о `Maven`) решить,
а если подключаешь библиотеку из интернета, то это библиотека почти всегда скомпилируется
(то есть практически у меня не было ни разу, чтобы что-то не скомпилировалось).
